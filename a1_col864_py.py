# -*- coding: utf-8 -*-
"""a1_col864.py

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/16tggN3k5kScywW3Wx0GTsUVrnMatBWFD
"""

import numpy as np

n, m = 30, 30
T = 100
world = np.zeros([30, 30])

sensor_reach = np.asarray([[0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5], 
						   [0.5, 0.6, 0.6, 0.6, 0.6, 0.6, 0.6, 0.6, 0.5],
						   [0.5, 0.6, 0.7, 0.7, 0.7, 0.7, 0.7, 0.6, 0.5],
						   [0.5, 0.6, 0.7, 0.8, 0.8, 0.8, 0.7, 0.6, 0.5],
						   [0.5, 0.6, 0.7, 0.8, 0.9, 0.8, 0.7, 0.6, 0.5],
						   [0.5, 0.6, 0.7, 0.8, 0.8, 0.8, 0.7, 0.6, 0.5],
						   [0.5, 0.6, 0.7, 0.7, 0.7, 0.7, 0.7, 0.6, 0.5],
						   [0.5, 0.6, 0.6, 0.6, 0.6, 0.6, 0.6, 0.6, 0.5],
						   [0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5]])

sensor_world = [[8, 15], [15, 15], [22, 15], [15, 22]]
sensors = [[15, 21], [15, 14], [15, 7], [22, 14]]
sensor_prob = [0.9, 0.8, 0.7, 0.6, 0.5]
num_sensors = len(sensors)

# four actions: up, right, down, left
motion_prob = np.asarray([0.4, 0.3, 0.1, 0.2])

l = [1,2,3]
l = l/np.sum(np.asarray(l))
a = np.sum(np.asarray(l))
motion_prob.shape

# translates the python matrix coordinates to world coordinates or vice-versa
def translate(x, y):
	x_new = n-1-x
	return y, x_new

# choose probabilistically - distribution 
def choose_prob(p_dist):
  p_dist = p_dist/np.sum(p_dist)
  r = np.random.rand()
  sum = p_dist[0]
  for i in range(p_dist.shape[0]-1):
    if r <= sum: return i
    else: sum += p_dist[i+1]
  return len(p_dist)-1

def update_coord(x, y, i):
  if i==0: x -= 1 #up
  elif i==1: y += 1 #right
  elif i==2: x += 1 # down
  elif i==3: y -= 1 # left
  return x, y

# index of direction of motion
def move_robot(loc):
  x, y = loc[0], loc[1]
  if x==0:
    if y==0: # top left corner
      d = choose_prob(motion_prob[1:3])+1
    elif y==29: # top right corner
      d = choose_prob(motion_prob[2:4])+2
    else: # top edge
      d = choose_prob(motion_prob[1:4])+1

  elif x==29:
    if y==0: # bottom left corner
      d = choose_prob(motion_prob[0:2])
    elif y==29: # bottom right corner
      d = choose_prob(np.asarray([motion_prob[0], 0, 0, motion_prob[3]]))
    else: # bottom edge
      d = choose_prob(np.asarray([motion_prob[0], motion_prob[1], 0, motion_prob[3]]))
  
  elif y==0: #left edge
    d = choose_prob(motion_prob[:3])
  
  elif y==29: #right edge
    d = choose_prob(np.asarray([motion_prob[0], 0, motion_prob[2], motion_prob[3]]))

  else:
    d = choose_prob(motion_prob)

  return update_coord(x, y, d)

move_robot([25, 21])

# (a)
# assuming robot to start from [15, 15] - python coordinates
robot_loc = np.zeros([T+1, 2])
sensor_data = np.zeros([T+1, len(sensors)])

robot_loc[0, :] = [15, 15]
for t in range(T):
  robot_loc[t+1, :] = move_robot(robot_loc[t, :])
  # print(robot_loc[t+1])

for t in range(T+1):
  for i in range(len(sensors)):
    dist = int(np.max(np.abs(robot_loc[t, :] - np.asarray(sensors[i]))))
    if dist<5:
      p = sensor_prob[dist]
      sensor_data[t][i] = choose_prob([1-p, p]) # 0 -> not detected, 1 -> detected

# print(robot_loc)
# print(sensor_data.T)

int(np.max(np.abs(robot_loc[1, :] - np.asarray(sensors[0]))))
# robot_loc[1,:]

# (b)
Bel_x = []
bel = np.ones([n, m])/(n*m)

for t in range(T+1):
  if t==0:
    for x in range(n):
      for y in range(m):
        bel[x][y] = 1
        for s in range(num_sensors):
          dist = int(max(abs(np.asarray([x-sensors[s][0], y-sensors[s][1]]))))
          p = sensor_prob[dist] if dist<5 else 0
          bel[x][y] *= p if sensor_data[t, s]==1 else (1-p)
    Bel_x.append(bel/np.sum(bel))
  else:
    for x in range(n):
      for y in range(m):
        tmp = 0
        if x>0: #from up
          tmp += motion_prob[2]*Bel_x[t-1][x-1][y]
        if y<29: #from right
          tmp += motion_prob[3]*Bel_x[t-1][x][y+1]
        if x<29: #from down
          tmp += motion_prob[1]*Bel_x[t-1][x+1][y]
        if y>0: #from left
          tmp += motion_prob[1]*Bel_x[t-1][x][y-1]
        for s in range(num_sensors):
          dist = int(max(abs(np.asarray([x-sensors[s][0], y-sensors[s][1]]))))
          p = sensor_prob[dist] if dist<5 else 0
          tmp *= p if sensor_data[t, s]==1 else (1-p)
        bel[x][y] = tmp
    Bel_x.append(bel/np.sum(bel))

# To print belief at time t
# l = []
# t = 25
# for x in range(n):
#   for y in range(m):
#     print(round(Bel_x[t][x][y], 3), end="  ")
#     if Bel_x[t][x][y]>0.0:
#       l.append([x,y])
#   print("\n")

# print(l)

import seaborn as sns; sns.set_theme()
ax = sns.heatmap(Bel_x[0])

t = 90
print(np.unravel_index(np.argmax(Bel_x[t], axis=None), Bel_x[t].shape))
robot_loc[t]

def sensor_model(sensor_data, t, x, y):
  tmp = 1
  for s in range(num_sensors):
    dist = int(max(abs(np.asarray([x-sensors[s][0], y-sensors[s][1]]))))
    p = sensor_prob[dist] if dist<5 else 0
    tmp *= p if sensor_data[t, s]==1 else (1-p)
  return tmp

# (c)
smooth = np.zeros([T+1, n, m])
smooth[T] = Bel_x[T]

for t in reversed(range(T)):
  for x in range(n):
    for y in range(m):
      bel[x][y] = Bel_x[t][x][y]
      tmp = 0
      if x>0: #to up
        s_tmp = sensor_model(sensor_data, t+1, x-1, y)
        s_tmp *= (smooth[t+1][x-1][y]*motion_prob[0])
        tmp += s_tmp
      if y<29: #to right
        s_tmp = sensor_model(sensor_data, t+1, x, y+1)
        s_tmp *= (smooth[t+1][x][y+1]*motion_prob[1])
        tmp += s_tmp
      if x<29: #to down
        s_tmp = sensor_model(sensor_data, t+1, x+1, y)
        s_tmp *= (smooth[t+1][x+1][y]*motion_prob[2])
        tmp += s_tmp
      if y>0: #to left
        s_tmp = sensor_model(sensor_data, t+1, x, y-1)
        s_tmp *= (smooth[t+1][x][y-1]*motion_prob[3])
        tmp += s_tmp
      bel[x][y] *= tmp
  smooth[t] = bel/np.sum(bel)

# To print belief at time t
l = []
t = 20
for x in range(n):
  for y in range(m):
    print(round(smooth[t][x][y], 3), end="  ")
    if smooth[t][x][y]>0.0:
      l.append([x,y])
  print("\n")

print(np.unravel_index(np.argmax(smooth[t], axis=None), smooth[t].shape))
print(robot_loc[t])

# d

